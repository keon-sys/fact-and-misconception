# 5장. 타입과 메시지

- 객체의 책임을 자율적으로 만드는 것이 품질의 핵심이다.
- 객체들 간 주고받는 메시지가 객체의 책임과 설계를 결정한다.

> 객체지향 어플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다.

## 자율적인 책임
- 객체가 자율적이기 위해서는 객체에게 할당되는 책임의 수준 역시 자율적이어야 한다.
- 너무 포괄적이고 추상적인 책임은 오히려 협력의 의도를 명확하게 표현하지 못하기 때문에 문제가 될 수 있다.
- 어떻게(how)가 아닌 무엇(what)을 해야 하는지에 대해 설명해야 한다.

```
왕이 모자장수에게 증언을 요청했을 때,
필요한 행동들을 좀 더 상세하게 요청했다면 어땠을까? 

모자장수는 본인이 할 수 있는 최적의 방법으로 증언할 수도 있었겠지만,
왕이 상세한 요청을 주는 바람에 행동에 제약이 생겼을 수도 있다.

'어떻게(how)' 할지는 객체 자율에 맡기고
'무엇(what)' 해야할지에만 초점을 맞춰주면 된다.
```

## 메시지와 메서드
```
'증언하라' = 메시지 /  '어제','왕국' = 인자 /  '모자장수' = 수신자
모자장수.증언하라(어제, 왕국)
```
### 메시지
- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.
- 객체가 메시지를 수신할 수 있다는 것은 객체가 해당하는 책임을 수행할 수 있다는 것을 의미한다.
- 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다.
### 메서드
- 메시지의 수신자 객체는 메시지를 처리할 방법으로 특정 메서드를 실행한다.
- 메시지의 수신자 객체가 런타임에 수행할 메서드를 결정하고 선택한다.

```
모자장수.증언하라(어제, 왕국)
앨리스.증언하라(어제, 왕국)

수신자는 메시지에 응답한다. 다만 메시지를 처리하는 방식은 수신자가 정한다.
송신자인 왕의 관점에선 이 객체들이 동일한 책임을 수행하고 있는 중이다.
```

여기서 질문
- 클래스 간 관계에 집중하면 객체 결합도가 높아지지만, 메시지를 사용하면 객체 결합도를 낮출 수 있다???

### 다형성
- 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.
- 서로 다른 타입의 객체들이 동일한 메시지에 대해 서로 다른 메서드를 이용해 메시지를 처리하는 메커니즘이다.
- 객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들 수 있기 때문이다.

## 메시지를 따라라
- 클래스가 코드를 구현하기 위해 사용할 수 있는 중요한 추상화 도구인 것은 맞지만, 객체지향의 강력함은 클래스가 아닌 객체들이 주고받는 메시지로부터 나온다.
- 클래스는 객체의 속성과 행위를 담는 틀일 뿐이다.
### 데이터-주도 설계
- 객체 자체에 초점을 맞출 경우 가장 흔히 범하게 되는 실수는, 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것이다.
- 데이터를 중심으로 객체를 설계하는 방식은 객체의 내부 구조를 객체 정의의 일부로 만들기 때문에 객체의 자율성을 저해한다.
- 따라서, 시스템의 기능을 구현하기 위해 객체가 다른 객체에게 제공해야 하는 메시지에 대해 고민해야 한다.
```
- 데이터 중심으로 객체를 설계하는 것. 데이터 구조(내부 구조)를 객체 정의의 일부로 만들어 버림
- 데이터 주도 설계 시 객체 내부구조를 바꾸기 어려움. 객체 내부로 바꾸면 외부까지 영향을 받게 됨
```
### 책임-주도 설계
- 객체들 간 주고받는 메시지를 기반으로 적절한 역할과 책임, 협력을 발견하는 것이 기본 아이디어다.
- 메시지가 수신자의 책임을 결정한다.
```
- 책임 완수를 목적으로 객체들을 이용해 시스템을 설계
- 데이터에 대한 결정보다 객체 행위에 대해 먼저 고려
- 객체가 책임 완수를 위해 다른 객체 도움을 필요로 하는지 판단한 후 (= 메시지가 필요한지 판단)
- 메시지가 필요하다고 판단되면 적합한 수신 객체를 선택하는 식으로 설계
수신자는 송신자가 보낸 메시지에 대한 기대(책임)를 만족시켜야 함
```

### What/Who 사이클
- 협력 관계 설계를 위해서는 어떤 행위(what) 가 필요한지를 먼저 결정한 후에 누가(who) 그 행위를 수행할 지 결정해야 한다.
- 협력이라는 문맥 안에서 객체의 책임을 결정하는 것은 메시지다. 책임이 먼저 오고 객체가 책임을 따른다.
- 이렇게 메시지를 먼저 결정함으로써 객체의 인터페이스를 발견할 수 있다.
### Tell, Don't Ask
- 메시지를 결정하는 시점에는 메시지 송신자는 수신자 객체의 내부 상태를 알 수 없기 때문에 두 객체는 느슨하게 결합된다.
- 송신자는 수신자가 자신이 전송한 메시지를 잘 처리할 것이라고 믿고 메시지를 전송할 수 밖에 없으며, 이 때 각 객체는 자율적이다.
```
- 'What'(메시지 = 어떤 행위를 수행할 것인지), 'Who' (수신 객체 = 누가) 그 행위를 수행할 것인지 결정
- ‘How’ 어떻게 처리할 지는 묻지 말고, 그냥 수신 객체에게 시키자!
- 책임을 완수할 것이라 믿고, 어떻게 처리할지는 객체에게 맡긴다
- 객체를 자율적으로 만들고 캡슐화를 보장한다
```

## 객체 인터페이스
> 우리는 TV를 켜기 위해 리모콘에 노출된 버튼을 누를 뿐, 실제 어떤 방식으로 동작하는지는 모른다
리모콘 버튼 사용법만 이해하고 있다면 우리는 원하는 결과를 얻을 수 있다.

> 리모콘과 같이 두 사물이 마주치는 경계지점에서 서로 상호작용할 수 있게 이어주는 방법 또는 장치를 인터페이스라고 하기도 한다. (인터페이스의 범용적 정의)
### 인터페이스의 특징
- 사용법만 알고 있으면 대상의 내부 구조나 동작 방법을 몰라도 상호 작용이 가능
- 인터페이스가 변경되지 않고 단순히 내부 구성이나 작동방식이 변경되는것은 - 사용자에게 영향을 미치지 않음.
- 인터페이스가 동일하기만 하다면 어떤 대상과도 상호 가능
- 인터페이스의 구성은 곧 객체가 외부로부터 수신할 수 있는 메시지 목록

### 메시지가 인터페이스를 결정한다
- 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성된다.
- 객체가 어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스의 모양을 결정한다.
### 공용 인터페이스
- 공용 인터페이스: 객체가 외부로부터 수신할 수 있는 메시지
- 내부 인터페이스: 객체가 자기 자신으로부터 주고받을 수 있는 메시지

## 인터페이스와 구현의 분리
> 메시지로 구성된 인터페이스는 객체 외부와 내부를 명확하게 구분한다.
>> 객체지향의 힘은 객체의 외부와 내부를 구분하는 것에서 나온다.

### 객체지향적 사고를 위한 세 가지 원칙
- 좀 더 추상적인 인터페이스 : 디테일한 메시지는 객체 자율성을 저해하므로 추상적인 메시지를 만들 것
- 최소 인터페이스 : 외부에서 사용할 필요 없는 인터페이스는 최대한 노출하지 말 것
- 인터페이스와 구현의 차이가 있다는 것을 인지할 것

### 구현(Implementation)
- 객체의 내부 구조와 작동 방식. 공용 인터페이스 외의 모든 부분

### 인터페이스와 구현의 분리 원칙
- 소프트웨어는 항상 변경되기 때문에, 객체의 내부 구현을 변경에 대한 안전 지대로 만들어 공용 인터페이스와 분리해야 한다.
- 객체 외부에 영향을 미치는 변경은 객체의 공용 인터페이스를 수정할 때뿐이어야 한다.
- 메시지와 송신자와 수신자가 구체적인 구현이 아니라 느슨한 인터페이스에 대해서만 결합되어야 한다.
### 캡슐화
- 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것
- 사적인 비밀을 캡슐화 (변경이 빈번하게 일어나는 사적인 범위는 캡슐화)

> 상태와 행위의 캡슐화
>> 데이터 캡슐화(data encapsulation) 

>> 객체는 상태와 행위를 하나의 자율적인 단위로 묶은 후, 외부에서 반드시 접근해야만 하는 행위만 골라 공용 인터페이스에 노출한다.

> 사적인 비밀의 캡슐화
>> 객체는 스스로 변경하고 조작할 수 있는 비밀, 즉 객체의 내부를 가지고 있다.

>> 외부의 객체가 자신의 내부 상태를 직접 관찰하거나 제어할 수 없도록 공용 인터페이스를 경계 삼아 비밀을 격리한다.

## 책임의 자율성이 협력의 품질을 결정한다
- 자율적이고 적절하게 추상화된 책임은 협력을 단순하게 만든다.
- 자율적인 책임은 객체의 외부인 공용 인터페이스와 내부를 명확하게 분리하고 캡슐화한다.
- 책임이 자율적인 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않아 결합도가 낮아진다.
- 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있도록 하기 때문에 설계가 유연해지고 재사용성이 높아진다.
- 객체가 수행하는 책임들이 자율적일수록 객체의 응집도를 높은 상태로 유지하기가 쉬우며 역햘을 이해하기 쉽다.

```
책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다.
그 이유는 아래와 같다.

첫째, 자율적인 책임은 협력을 단순하게 만든다
둘째, 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.
셋째, 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.
넷째, 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
다섯째, 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.
```

# 결론
- 협력 관계에서 주고받는 메시지가 객체의 책임을 결정하고, 그 책임을 자율적으로 만드는 것이 어플리케이션의 품질을 결정한다는 것을 배웠다. 객체의 자율성은 곧 객체의 캡슐화와 연결된다. 객체는 협력을 위해 필수로 제공해야 하는 행동(메서드)는 공용 인터페이스를 통해 공개하고 나머지 내부 상태와 행동은 외부에서 접근할 수 없게 숨겨야 한다. 그렇게 캡슐화함으로써 객체는 객체지향 공동체와 느슨한 결합을 유지하게 되고 쉽고 유연하게 협력을 할 수 있게 된다.
- 위의 말을 이해해야 한다? 

# 6장. 객체 지도
- 자주 변경되는 기능이 아니라 안정적인 구조를 따라 역할, 책임, 협력을 구성하라
- 미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다.

```
길을 찾기 위한 두 가지 방법이 있다.
첫 번째는 다른 사람에게 길을 물어보는 것이고, 두 번째는 지도로 지형을 파악한 후 찾아가는 방법이다.
첫 번째 방법은 기능적이고 해결 지향적이다. 반면, 두 번째 방법은 구조적이고 문제 지향적이다. 
두 번째 지도를 활용한 방법은 길을 찾기 위한 구체적인 '기능'이 아니라, 길을 찾을 수 있는 '구조'를 제공한다.

6장은 객체 설계를 지도에 빗대어 기능과 구조를 사용한 설계 방법 등에 대해 설명한다.
```

## 기능 설계 vs 구조 설계
- 기능(function) 설계: 제품이 사용자를 위해 무엇을 할 수 있는가
- 구조(structure) 설계: 제품의 형태가 어떠해야 하는가
- 기능과 구조라는 두 가지 측면을 함께 녹여 조화를 이루도록 만들어야 한다.
- 즉, 훌륭한 기능을 제공하는 동시에 새로운 기능을 빠르고 안정적으로 추가할 수 있어야 한다.

```
사용자가 원하는 기능을 제공할 수 있다면 설계가 어떠한지는 중요하지 않을 수 있다.
다만, 이 가정은 사용자가 원하는 기능(요구사항)이 바뀌지 않는다는 전제가 필요하다.

요구사항은 끊임없이 변경되기 때문에 이에 빠르게 대응하기 위해선 기능에 집중하기 보다 변화에 유연하게 대응할 수 있는, 비교적 불변하는 구조에 초점을 맞춰 설계해야 한다.

기능 중심으로 설계를 하게 되면 요구사항이 변경될 때마다 소프트웨어 전체가 요동칠 수 있다.
```

## 두 가지 재료: 기능과 구조
> 객체 지향 세계를 구축하기 위해선 사용자에게 제공할 '기능'과 기능을 담을 안정적인 '재료'가 필요하다

```
기능
- 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현
- 유스케이스 모델링 : 기능을 수집하고 표현하기 위한 기법
구조
- 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들과 관계로 표현
- 도메인 모델링 : 구조를 수집하고 표현하기 위한 기법
```

### 안정적인 재료: 구조
- 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.

### 도메인 모델
- 도메인(domain): 사용자가 프로그램을 사용하는 대상 분야
- 도메인 모델: 소프트웨어가 목적하는 영역 내의 개념과 개념 간의 관계 등을 주의 깊게 추상화한 형태
```
도메인 모델
사용자가 사용하고자 하는 대상 영역에 관현 지식을 (= 도메인)
선택적으로 단순화 하고 의식적으로 구조화한 형태 (= 모델)
```

- 최종 제품은 사용자의 관점을 반영해야 한다. 디자인 모델을 기반으로 만든 시스템이 사용자 모델을 정확하게 반영하도록 노력해야 한다.
- 따라서, 소프트웨어 객체는 도메인 모델을 통해 표현되는 도메인 객체들을 은유해야 한다.

```
 도메인 모델은 단순한 다이어그램이 아닌 이해 관계자들이 바라보는 관점/개념. 즉, 멘탈모델로 모델링 되어야 한다.
사용자들은 도메인의 본질을 잘 이해하고 있는 사람들이며, 도메인은 쉽게 변하지 않기 때문에 기능보다 안정적인 구조를 제공할 수 있다.
```
#### 도메인 모델은
-  사용자들이 바라보는 관점이자
-  설계자가 시스템 구조를 바라보는 관점이며
-  동시에 소프트웨어 내에 구현된 코드 모습이다.

```
이 세 이미지가 모두 유사한 모습을 가져야 하며 객체지향은 이를 가능하게 해준다.

세 이미지가 유사한 모습을 가져야 한다는 것은 '모방'이 필요하다는 의미가 아니다.

앞서 얘기 되었듯 객체지향 세계는 현실세계에 대한 '모방'이 아니며, 현실세계에서 불가능한 것들, 실제 존재하지 않는 것들이 있을 수 있다.

이런 객체지향 세계와 현실세계의 차이는 '은유'를 통해 해결될 수 있다.
```

### 불안정한 재료: 기능
- 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.

> 시스템은 사용자의 목표를 해결하기 위해 '기능'을 제공한다.

> 우리는 '기능'을 사용자-시스템 간 목표해결을 위한 '상호작용' 관점에서 바라봐야 한다.

### 유즈케이스
- 사용자와 시스템 간 이뤄지는 상호작용의 흐름을 정리하는 기법
- 사용자들의 목표를 중심으로 연관된 시스템의 기능적 요구사항들을 이야기 형식으로 묶을 수 있다.
- 도메인과 객체는 유즈케이스로부터 자동으로 변환되는 것이 아니며, 영감이나 힌트만이 들어 있을 뿐이다.

```
사용자와 시스템 간 상호작용을 보여주는 텍스트이다.
하나의 시나리오가 아닌 여러 시나리오들의 집합이다.
단순한 피처 목록과 다르다. 즉, 단순하게 기능 목록을 나열한 것과 다르다.
사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.
내부 설계 관련 정보도 포함하지 말아야 한다.

유스케이스는 설계나 객체지향 기법이 아니다.
단지 사용자가 시스템을 통해 무엇을 얻을 수 있고 그 과정에서 어떻게 상호작용하는지만 기술된다
```

## 재료 합치기: 기능과 구조의 통합

> 도메인 모델은 안정적인 구조를 개념화하기 위한 도구이고,

> 유스케이스는 불안정한 기능을 서술하기 위해 사용되는 도구이다. 

변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템 기능을 도메인 모델 기반으로 한 객체들의 책임으로 분배해야 한다.

### 책임-주도 설계
- 요구사항들을 식별하고 도메인 모델을 생성한 후, 소프트웨어 클래스에 메소드를 추가하고, 요구사항을 충족시키기 위한 객체들 간 메시지 전송을 정의한다.
- 사용자의 관점에서 시스템의 기능을 명시하고, 사용자와 설계자가 공유하는 안정적인 구조를 기반으로 기능을 책임으로 변환하는 체계적인 절차를 따라야 한다.
- 안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하라.
- 도메인 모델과 코드를 밀접하게 연관시키기 위해 노력하라.

```

책임-주도 설계는 유스케이스로부터 첫 번째 메시지와 사용자가 달성하려는 목표를 추출하고 도메인 모델로부터 구조를 제공받아 실제 동작하는 객체들의 협력 공동체를 창조한다.

첫 번째 메시지를 통해 목표 달성을 위한 기능 제공 책임을 맡은 시스템은
맡은 책임을 시스템 내 작은 규모로 세분화하고 이 과정을 반복하면서 객체 간 협력을 완성해간다. 

책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력관계로 바라보게 함으로써 두 가지 기본재료인 유스케이스와 도메인 모델을 통합한다.
```

# 결론
- 각자가 생각하는 책임주도 설계는 무엇인가요??